'use client'

import { useState, useEffect } from 'react'
import { 
  Stack, 
  TextInput, 
  Textarea, 
  Button, 
  Text, 
  Title, 
  Card, 
  Group,
  Select,
  Chip,
  Alert,
  ScrollArea,
  Divider
} from '@mantine/core'
import { generateContentForType } from '../../lib/ai-client'
import { startConversation, endConversation, trackTurn } from '../../lib/bilan'

export interface TopicExplorationData {
  topic: string
  audience: string
  keyPoints: string[]
  tone: string
  initialBrief?: string
  conversationHistory?: Array<{ role: 'user' | 'assistant'; content: string }>
}

/**
 * Props interface for the TopicExplorationStep component
 * 
 * Defines the required properties for the topic exploration workflow step component,
 * which handles the initial phase of blog content creation through conversational
 * AI interaction. This component enables users to discover, refine, and finalize
 * their blog topic, target audience, key points, and desired tone through an
 * interactive discussion process.
 * 
 * @interface TopicExplorationStepProps
 * 
 * @description
 * **Component Purpose:**
 * The TopicExplorationStep component serves as the entry point for the blog creation
 * workflow, providing users with a conversational interface to explore and develop
 * their content ideas. It facilitates topic discovery, audience identification,
 * and content planning through AI-assisted conversation.
 * 
 * **Workflow Integration:**
 * This component integrates with the broader BlogWorkflow by:
 * - Accepting journey tracking identifiers for analytics correlation
 * - Providing completion callback mechanism for workflow progression
 * - Generating structured topic data for subsequent workflow steps
 * - Maintaining conversation history for context and user experience
 * 
 * **User Experience:**
 * The component enables users to:
 * - Engage in natural conversation about their blog ideas
 * - Receive AI guidance for topic refinement and audience targeting
 * - Develop comprehensive content plans through interactive discussion
 * - Review and finalize topic data before proceeding to outline generation
 * 
 * @example
 * ```typescript
 * <TopicExplorationStep
 *   journeyId="journey_abc123"
 *   onComplete={(data) => {
 *     console.log('Topic exploration completed:', data.topic)
 *     // Advance to outline generation step
 *   }}
 * />
 * ```
 */
export interface TopicExplorationStepProps {
  /**
   * Unique identifier for the Bilan analytics journey tracking
   * 
   * This string serves as the primary correlation key for tracking user interactions
   * and workflow progression throughout the blog creation process. It enables
   * comprehensive analytics collection, user journey analysis, and step-by-step
   * performance measurement within the Bilan analytics system.
   * 
   * **Analytics Integration:**
   * - Links all topic exploration interactions to the broader blog creation journey
   * - Enables correlation between conversation turns and final topic outcomes
   * - Supports user journey mapping and workflow optimization analysis
   * - Facilitates A/B testing and user experience improvement initiatives
   * 
   * **Data Flow:**
   * The journeyId is typically:
   * - Generated by the parent BlogWorkflow component during workflow initialization
   * - Passed down to all workflow step components for consistent tracking
   * - Used in all Bilan analytics calls (trackTurn, vote, trackJourneyStep)
   * - Maintained throughout the entire blog creation session
   * 
   * @type {string}
   * @example "journey_1701234567_abc123def456"
   */
  journeyId: string

  /**
   * Callback function invoked when topic exploration step is completed
   * 
   * This function serves as the primary communication mechanism between the
   * TopicExplorationStep component and its parent BlogWorkflow component,
   * triggering workflow progression and passing collected topic data to
   * subsequent steps in the blog creation process.
   * 
   * **Callback Trigger:**
   * The function is called when:
   * - User completes the conversational topic exploration process
   * - All required topic data has been collected and validated
   * - User confirms their topic selection and audience targeting
   * - Component is ready to advance to the outline generation step
   * 
   * **Data Parameter:**
   * The callback receives a TopicExplorationData object containing:
   * - **topic**: Final refined blog topic selected by the user
   * - **audience**: Target audience identified through exploration
   * - **keyPoints**: Array of key points/themes to cover in the blog
   * - **tone**: Desired writing tone (professional, casual, technical, etc.)
   * - **initialBrief**: Optional original user input for context
   * - **conversationHistory**: Complete conversation log for reference
   * 
   * **Parent Component Handling:**
   * The parent BlogWorkflow component typically uses this callback to:
   * - Update overall workflow state with topic exploration results
   * - Progress to the next workflow step (outline generation)
   * - Track step completion with Bilan analytics
   * - Update UI progress indicators and navigation state
   * 
   * **Error Handling:**
   * The callback should handle potential errors gracefully:
   * - Validate received data structure and completeness
   * - Provide user feedback for incomplete or invalid data
   * - Maintain workflow state consistency in case of failures
   * - Log errors for debugging while protecting user experience
   * 
   * @type {function}
   * @param {TopicExplorationData} data - Aggregated topic exploration results
   * @returns {void} - No return value expected
   * 
   * @example
   * ```typescript
   * const handleTopicComplete = (data: TopicExplorationData) => {
   *   // Update workflow state
   *   setWorkflowState(prev => ({
   *     ...prev,
   *     topicData: data,
   *     currentStep: 'outline-generation',
   *     completedSteps: [...prev.completedSteps, 'topic-exploration']
   *   }))
   *   
   *   // Track completion with analytics
   *   trackJourneyStep(journeyId, 'topic-exploration', { 
   *     completionStatus: 'completed',
   *     topicSelected: data.topic,
   *     audienceIdentified: data.audience
   *   })
   * }
   * ```
   */
  onComplete: (data: TopicExplorationData) => void
}

interface ConversationMessage {
  role: 'user' | 'assistant'
  content: string
  timestamp: number
  turnId?: string
}

const TONE_OPTIONS = [
  { value: 'professional', label: 'Professional' },
  { value: 'casual', label: 'Casual' },
  { value: 'friendly', label: 'Friendly' },
  { value: 'formal', label: 'Formal' },
  { value: 'conversational', label: 'Conversational' },
  { value: 'authoritative', label: 'Authoritative' }
]

const AUDIENCE_SUGGESTIONS = [
  'Developers', 'Entrepreneurs', 'Students', 'Professionals', 
  'Beginners', 'Experts', 'General Public', 'Industry Specialists'
]

export function TopicExplorationStep({ journeyId, onComplete }: TopicExplorationStepProps) {
  const [messages, setMessages] = useState<ConversationMessage[]>([])
  const [currentInput, setCurrentInput] = useState('')
  const [isGenerating, setIsGenerating] = useState(false)
  const [conversationId, setConversationId] = useState<string>('')
  const [hasStartedConversation, setHasStartedConversation] = useState(false)

  // Form state for topic refinement
  const [topic, setTopic] = useState('')
  const [audience, setAudience] = useState('')
  const [selectedKeyPoints, setSelectedKeyPoints] = useState<string[]>([])
  const [suggestedKeyPoints, setSuggestedKeyPoints] = useState<string[]>([])
  const [tone, setTone] = useState<string>('professional')
  const [showRefinementForm, setShowRefinementForm] = useState(false)

  // Start conversation when component mounts
  useEffect(() => {
    const initConversation = async () => {
      try {
        const convId = await startConversation({
          journeyId,
          topic: 'blog-topic-exploration',
          contentType: 'blog'
        })
        
        if (convId) {
          setConversationId(convId)
          
          // Add initial AI message
          const initialMessage: ConversationMessage = {
            role: 'assistant',
            content: `Hi! I'm here to help you explore and refine your blog topic. Let's start by understanding what you'd like to write about.

What's your initial idea for the blog post? It could be:
• A problem you want to solve
• A topic you're passionate about  
• Something you've learned recently
• An industry trend or insight

Don't worry if it's not fully formed yet - we'll develop it together!`,
            timestamp: Date.now()
          }
          
          setMessages([initialMessage])
          setHasStartedConversation(true)
        }
      } catch (error) {
        console.error('Failed to start conversation:', error)
      }
    }

    initConversation()
  }, [journeyId])

  const handleSendMessage = async () => {
    if (!currentInput.trim() || isGenerating || !conversationId) return

    const userMessage: ConversationMessage = {
      role: 'user',
      content: currentInput,
      timestamp: Date.now()
    }

    setMessages(prev => [...prev, userMessage])
    setCurrentInput('')
    setIsGenerating(true)

    try {
      // Build conversation context for AI
      const conversationContext = [...messages, userMessage]
        .map(msg => `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.content}`)
        .join('\n\n')

      const prompt = `You are an expert content strategist helping a user explore and refine their blog topic. Based on our conversation so far, provide helpful guidance.

Conversation so far:
${conversationContext}

Please respond as a helpful content strategist by:
1. Acknowledging what the user shared
2. Asking thoughtful follow-up questions to help clarify the topic
3. Suggesting specific angles or focuses
4. If the topic seems well-defined, start identifying key points and target audience

Keep your response conversational, encouraging, and focused on helping them develop a compelling blog topic.`

      // Track the turn with Bilan
      const { result, turnId } = await trackTurn(
        currentInput,
        () => generateContentForType('blog', prompt),
        {
          contentType: 'blog',
          iterationNumber: messages.length / 2 + 1,
          conversationId,
          journey_id: journeyId,
          journey_step: 'topic-exploration',
          userIntent: 'topic-exploration'
        }
      )

      const aiMessage: ConversationMessage = {
        role: 'assistant',
        content: result.text,
        timestamp: Date.now(),
        turnId
      }

      setMessages(prev => [...prev, aiMessage])

      // Auto-extract potential topic and key points from conversation
      await extractTopicInsights([...messages, userMessage, aiMessage])

    } catch (error) {
      console.error('Failed to generate response:', error)
      
      const errorMessage: ConversationMessage = {
        role: 'assistant',
        content: 'I apologize, but I encountered an error generating my response. Please try again or continue with the topic refinement form below.',
        timestamp: Date.now()
      }
      
      setMessages(prev => [...prev, errorMessage])
    } finally {
      setIsGenerating(false)
    }
  }

  const extractTopicInsights = async (conversationMessages: ConversationMessage[]) => {
    try {
      // Extract insights from the conversation to pre-populate the form
      const conversationText = conversationMessages
        .map(msg => msg.content)
        .join(' ')

      const extractionPrompt = `Based on this conversation about a blog topic, extract the following information and respond with ONLY a valid JSON object:

Conversation: ${conversationText}

Analyze the conversation and extract:
- topic: The main blog topic or title (string, or null if unclear)
- audience: The target audience (string, or null if not mentioned)
- keyPoints: Array of 3-5 key points or subtopics (array of strings, or empty array if none identified)

Respond with ONLY a JSON object in this exact format:
{
  "topic": "extracted topic or null",
  "audience": "target audience or null", 
  "keyPoints": ["point 1", "point 2", "point 3"]
}

Do not include any explanation or additional text - only the JSON object.`

      const { result } = await trackTurn(
        'Extract topic insights',
        () => generateContentForType('blog', extractionPrompt),
        {
          contentType: 'blog',
          conversationId,
          journey_id: journeyId,
          journey_step: 'topic-exploration',
          userIntent: 'topic-extraction'
        }
      )

      // Parse the JSON response safely
      try {
        // Clean the response text by removing any potential markdown code blocks or extra whitespace
        const cleanedResponse = result.text
          .replace(/```json\s*/g, '')
          .replace(/```\s*/g, '')
          .trim()

        const insights = JSON.parse(cleanedResponse)

        // Validate the JSON structure and extract insights
        if (insights && typeof insights === 'object') {
          // Extract topic if present and valid
          if (insights.topic && typeof insights.topic === 'string' && insights.topic.toLowerCase() !== 'null' && !topic) {
            setTopic(insights.topic.trim())
          }

          // Extract audience if present and valid
          if (insights.audience && typeof insights.audience === 'string' && insights.audience.toLowerCase() !== 'null' && !audience) {
            setAudience(insights.audience.trim())
          }

          // Extract key points if present and valid
          if (Array.isArray(insights.keyPoints) && insights.keyPoints.length > 0) {
            const validKeyPoints = insights.keyPoints
              .filter((point: unknown): point is string => typeof point === 'string' && point.trim().length > 0)
              .map((point: string) => point.trim())
            
            if (validKeyPoints.length > 0) {
              setSuggestedKeyPoints(validKeyPoints)
            }
          }
        }
      } catch (jsonError) {
        console.warn('Failed to parse JSON from AI response, falling back to text parsing:', jsonError instanceof Error ? jsonError.message : 'Unknown JSON error')
        
        // Fallback to original string parsing if JSON parsing fails
        const lines = result.text.split('\n')
        lines.forEach(line => {
          if (line.includes('topic') && !line.toLowerCase().includes('null') && !topic) {
            const match = line.match(/"topic":\s*"([^"]+)"/i)
            if (match && match[1]) {
              setTopic(match[1].trim())
            }
          }
          if (line.includes('audience') && !line.toLowerCase().includes('null') && !audience) {
            const match = line.match(/"audience":\s*"([^"]+)"/i)
            if (match && match[1]) {
              setAudience(match[1].trim())
            }
          }
          if (line.includes('keyPoints') && line.includes('[')) {
            const match = line.match(/"keyPoints":\s*\[([^\]]+)\]/i)
            if (match && match[1]) {
              const points = match[1]
                .split(',')
                .map(p => p.replace(/"/g, '').trim())
                .filter(p => p.length > 0)
              if (points.length > 0) {
                setSuggestedKeyPoints(points)
              }
            }
          }
        })
      }

      // Show refinement form if we have some insights
      if (conversationMessages.length >= 4) {
        setShowRefinementForm(true)
      }

    } catch (error) {
      console.error('Failed to extract topic insights:', error instanceof Error ? error.message : 'Unknown error')
    }
  }

  const handleKeyPointToggle = (point: string) => {
    setSelectedKeyPoints(prev => 
      prev.includes(point) 
        ? prev.filter(p => p !== point)
        : [...prev, point]
    )
  }

  /**
   * Finalizes the topic exploration process and triggers workflow progression
   * 
   * This asynchronous function serves as the completion handler for the topic exploration
   * workflow step, responsible for validating topic readiness, ending active conversations,
   * aggregating all exploration data into a structured format, and triggering advancement
   * to the next workflow step through the onComplete callback.
   * 
   * **Core Functionality:**
   * - Validates that a meaningful topic has been defined before allowing completion
   * - Gracefully ends active AI conversation sessions with completion status and metadata
   * - Aggregates all topic exploration data into structured TopicExplorationData format
   * - Invokes parent component callback to trigger workflow progression
   * - Handles completion errors gracefully with secure logging to maintain user experience
   * 
   * **Completion Process:**
   * 1. **Topic Validation**: Verify topic exists and contains meaningful content (early return if empty)
   * 2. **Conversation Closure**: End active conversation session if one exists with success metadata
   * 3. **Data Aggregation**: Compile exploration results into TopicExplorationData object
   * 4. **Callback Invocation**: Call onComplete to pass data to parent and advance workflow
   * 5. **Error Handling**: Catch and log any completion failures without disrupting user flow
   * 
   * **Data Aggregation Logic:**
   * The function constructs a comprehensive TopicExplorationData object containing:
   * - **topic**: Trimmed final topic string ensuring no leading/trailing whitespace
   * - **audience**: Target audience or fallback to 'General audience' if not specified
   * - **keyPoints**: Selected key points array, falling back to first 3 suggested points if none selected
   * - **tone**: User-selected writing tone for content consistency
   * - **initialBrief**: First user message from conversation for context preservation
   * - **conversationHistory**: Complete conversation log with role and content mapping
   * 
   * **Conversation Management:**
   * If an active conversation exists (conversationId is set), the function:
   * - Calls endConversation with 'completed' status indicating successful conclusion
   * - Includes satisfaction score of 1 assuming positive completion
   * - Sets outcome to 'topic-defined' for analytics categorization
   * - Passes final topic for conversation outcome tracking
   * 
   * **Early Return Behavior:**
   * The function implements validation by returning early if no topic content
   * exists, preventing workflow progression with incomplete data and maintaining
   * user experience by requiring meaningful topic definition before advancement.
   * 
   * **Workflow Integration:**
   * This completion handler integrates with the broader blog workflow by:
   * - Preserving all topic exploration data for subsequent outline generation
   * - Enabling context-aware outline creation based on defined topic and audience
   * - Maintaining conversation history for reference throughout workflow
   * - Providing foundation data for AI-assisted content creation in later steps
   * 
   * @async
   * @function handleComplete
   * @returns {Promise<void>} Promise that resolves when completion process finishes
   * 
   * @throws {Error} Conversation ending failures, data aggregation errors, or callback failures are caught and logged securely
   * 
   * @description
   * **Parameters:**
   * This function takes no explicit parameters but operates on component state:
   * - **topic**: Current topic string from component state
   * - **audience**: Target audience from component state
   * - **selectedKeyPoints**: User-selected key points array
   * - **suggestedKeyPoints**: AI-suggested key points for fallback
   * - **tone**: Selected writing tone
   * - **messages**: Complete conversation message history
   * - **conversationId**: Active conversation identifier (if exists)
   * 
   * **Error Handling:**
   * All errors are caught and logged securely to prevent exposure of sensitive
   * information while maintaining debugging capability. The function continues
   * execution and user experience is preserved even if conversation ending or
   * data processing encounters issues.
   * 
   * **Key Point Selection Logic:**
   * The function uses intelligent fallback for key points:
   * - Primary: Use selectedKeyPoints if user has made selections
   * - Fallback: Use first 3 suggestedKeyPoints to ensure content direction
   * - This ensures workflow always proceeds with meaningful content guidance
   * 
   * **Data Integrity:**
   * The function ensures data quality through:
   * - String trimming to remove whitespace artifacts
   * - Fallback values for optional fields (audience, keyPoints)
   * - Conversation history preservation for context maintenance
   * - Type-safe data structure construction
   * 
   * **Analytics Integration:**
   * The completion process supports analytics through:
   * - Conversation ending with outcome categorization
   * - Satisfaction score recording for success measurement
   * - Topic preservation for content analysis
   * - Complete data handoff to parent workflow for journey tracking
   * 
   * @example
   * ```typescript
   * // User clicks "Continue to Outline Generation" after defining topic
   * await handleComplete()
   * 
   * // Function execution flow:
   * // 1. Validates topic.trim() exists (e.g., "AI in Healthcare")
   * // 2. Ends conversation if active:
   * //    endConversation(conversationId, 'completed', {
   * //      satisfactionScore: 1,
   * //      outcome: 'topic-defined',
   * //      finalTopic: "AI in Healthcare"
   * //    })
   * // 3. Creates TopicExplorationData:
   * //    {
   * //      topic: "AI in Healthcare",
   * //      audience: "Healthcare Professionals",
   * //      keyPoints: ["Diagnosis", "Treatment", "Research"],
   * //      tone: "professional",
   * //      initialBrief: "I want to write about AI applications...",
   * //      conversationHistory: [{role: 'user', content: '...'}, ...]
   * //    }
   * // 4. Calls onComplete(explorationData) to advance workflow
   * ```
   */
  const handleComplete = async () => {
    if (!topic.trim()) {
      return
    }

    try {
      // End the conversation
      if (conversationId) {
        await endConversation(conversationId, 'completed', {
          satisfactionScore: 1,
          outcome: 'topic-defined',
          finalTopic: topic
        })
      }

      // Prepare the topic exploration data
      const explorationData: TopicExplorationData = {
        topic: topic.trim(),
        audience: audience.trim() || 'General audience',
        keyPoints: selectedKeyPoints.length > 0 ? selectedKeyPoints : suggestedKeyPoints.slice(0, 3),
        tone,
        initialBrief: messages.find(m => m.role === 'user')?.content || '',
        conversationHistory: messages.map(m => ({ role: m.role, content: m.content }))
      }

      onComplete(explorationData)
    } catch (error) {
      // Sanitize error logging to prevent exposure of sensitive information
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred'
      console.error('Failed to complete topic exploration:', errorMessage)
    }
  }

  return (
    <Stack gap="lg">
      <div>
        <Title order={3} mb="xs">Topic Exploration</Title>
        <Text c="dimmed" size="sm">
          Let's have a conversation to discover and refine your blog topic. Share your initial ideas and I'll help you develop them.
        </Text>
      </div>

      {/* Conversation Interface */}
      <Card withBorder p="md">
        <Text fw={500} mb="sm">Conversation</Text>
        
        <ScrollArea h={300} mb="md">
          <Stack gap="sm">
            {messages.map((message, index) => (
              <Card 
                key={index}
                p="sm"
                withBorder={message.role === 'user'}
                bg={message.role === 'user' ? 'blue.0' : 'gray.0'}
              >
                <Text size="sm" fw={500} mb="xs" c={message.role === 'user' ? 'blue' : 'dark'}>
                  {message.role === 'user' ? 'You' : 'AI Assistant'}
                </Text>
                <Text size="sm" style={{ whiteSpace: 'pre-wrap' }}>
                  {message.content}
                </Text>
              </Card>
            ))}
            
            {isGenerating && (
              <Card p="sm" bg="gray.0">
                <Text size="sm" fw={500} mb="xs" c="dark">AI Assistant</Text>
                <Text size="sm" c="dimmed">Thinking...</Text>
              </Card>
            )}
          </Stack>
        </ScrollArea>

        <Group gap="sm">
          <TextInput
            flex={1}
            placeholder="Share your blog topic ideas..."
            value={currentInput}
            onChange={(e) => setCurrentInput(e.target.value)}
            onKeyDown={(e) => e.key === 'Enter' && !e.shiftKey && handleSendMessage()}
            disabled={isGenerating}
          />
          <Button 
            onClick={handleSendMessage}
            disabled={!currentInput.trim() || isGenerating}
            loading={isGenerating}
          >
            Send
          </Button>
        </Group>
      </Card>

      {/* Topic Refinement Form */}
      {showRefinementForm && (
        <>
          <Divider label="Topic Refinement" labelPosition="center" />
          
          <Card withBorder p="md">
            <Text fw={500} mb="md">Refine Your Topic Details</Text>
            
            <Stack gap="md">
              <TextInput
                label="Blog Topic/Title"
                placeholder="Enter your refined blog topic..."
                value={topic}
                onChange={(e) => setTopic(e.target.value)}
                required
              />

              <TextInput
                label="Target Audience"
                placeholder="Who is this blog post for?"
                value={audience}
                onChange={(e) => setAudience(e.target.value)}
              />

              <div>
                <Text size="sm" fw={500} mb="xs">Key Points to Cover</Text>
                <Text size="xs" c="dimmed" mb="sm">
                  Select the key points you want to cover in your blog post:
                </Text>
                <Group gap="xs">
                  {suggestedKeyPoints.map((point) => (
                    <Chip
                      key={point}
                      checked={selectedKeyPoints.includes(point)}
                      onChange={() => handleKeyPointToggle(point)}
                      size="sm"
                    >
                      {point}
                    </Chip>
                  ))}
                </Group>
                {selectedKeyPoints.length === 0 && suggestedKeyPoints.length === 0 && (
                  <Text size="xs" c="dimmed">
                    Continue the conversation above to get suggested key points
                  </Text>
                )}
              </div>

              <Select
                label="Tone & Style"
                value={tone}
                onChange={(value) => setTone(value || 'professional')}
                data={TONE_OPTIONS}
              />
            </Stack>
          </Card>
        </>
      )}

      {/* Action Buttons */}
      <Group justify="space-between">
        <div>
          {!showRefinementForm && hasStartedConversation && (
            <Button 
              variant="light" 
              onClick={() => setShowRefinementForm(true)}
            >
              Skip to Topic Form
            </Button>
          )}
        </div>
        
        <Button 
          onClick={handleComplete}
          disabled={!topic.trim()}
          size="md"
        >
          Complete Topic Exploration
        </Button>
      </Group>

      {!topic.trim() && showRefinementForm && (
        <Alert color="yellow" title="Topic Required">
          Please enter a blog topic to continue to the next step.
        </Alert>
      )}
    </Stack>
  )
} 