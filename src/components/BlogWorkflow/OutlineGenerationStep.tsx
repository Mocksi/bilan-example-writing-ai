'use client'

import { useState, useEffect } from 'react'
import { 
  Stack, 
  Button, 
  Text, 
  Title, 
  Card, 
  Group,
  Textarea,
  Alert,
  Divider,
  Badge,
  Paper,
  ActionIcon,
  Loader
} from '@mantine/core'
import { generateContentForType } from '../../lib/ai-client'
import { trackTurn, vote } from '../../lib/bilan'
import type { TopicExplorationData } from './TopicExplorationStep'

/**
 * Data structure containing the generated blog post outline and associated metadata
 * 
 * This interface represents the output of the outline generation step in the blog
 * creation workflow. It includes both the raw outline text and structured section
 * data that will be used in subsequent workflow steps.
 * 
 * @interface OutlineGenerationData
 * @property {string} outline - The complete outline text generated by AI, formatted with headers and bullet points
 * @property {Array<{ title: string; description: string }>} sections - Structured array of sections extracted from the outline
 * @property {number} estimatedWordCount - AI-generated estimate of final blog post length based on outline scope
 * @property {number} generatedAt - Unix timestamp indicating when the outline was created
 */
export interface OutlineGenerationData {
  outline: string
  sections: Array<{ title: string; description: string }>
  estimatedWordCount: number
  generatedAt: number
}

/**
 * Props interface for the OutlineGenerationStep component
 * 
 * Defines the required inputs for the outline generation step of the blog workflow.
 * This component takes topic exploration data and generates a structured outline
 * that serves as the blueprint for the blog post creation process.
 * 
 * @interface OutlineGenerationStepProps
 * @property {string} journeyId - Unique identifier for the current blog creation journey (for Bilan analytics)
 * @property {TopicExplorationData} [topicData] - Optional topic data from previous step containing user's topic, audience, and key points
 * @property {function} onComplete - Callback function invoked when outline generation is complete, receives OutlineGenerationData
 */
export interface OutlineGenerationStepProps {
  journeyId: string
  topicData?: TopicExplorationData
  onComplete: (data: OutlineGenerationData) => void
}

/**
 * Internal data structure representing a single section within the blog outline
 * 
 * Used internally by the component to parse and structure sections extracted
 * from the AI-generated outline text. Each section represents a major part
 * of the planned blog post.
 * 
 * @interface OutlineSection
 * @property {string} title - The section heading or title (e.g., "Introduction", "Main Benefits")  
 * @property {string} description - Brief description of what content this section should cover
 */
interface OutlineSection {
  title: string
  description: string
}

export function OutlineGenerationStep({ journeyId, topicData, onComplete }: OutlineGenerationStepProps) {
  const [outline, setOutline] = useState('')
  const [sections, setSections] = useState<OutlineSection[]>([])
  const [isGenerating, setIsGenerating] = useState(false)
  const [hasGenerated, setHasGenerated] = useState(false)
  const [isAutoGenerating, setIsAutoGenerating] = useState(false)
  const [estimatedWordCount, setEstimatedWordCount] = useState(0)
  const [turnId, setTurnId] = useState<string>('')
  const [userVote, setUserVote] = useState<1 | -1 | null>(null)

  // Auto-generate outline when component mounts if we have topic data
  useEffect(() => {
    if (topicData && !hasGenerated && !isGenerating) {
      setIsAutoGenerating(true)
      handleGenerateOutline()
    }
  }, [topicData, hasGenerated, isGenerating])

  /**
   * Constructs a comprehensive AI prompt for generating structured blog post outlines
   * 
   * This function builds a detailed prompt string that provides the AI with all necessary
   * context from the topic exploration phase to generate a well-structured blog outline.
   * The prompt is designed to ensure consistent, parseable output with clear formatting
   * directives that facilitate downstream processing in the workflow.
   * 
   * @function buildOutlinePrompt
   * @returns {string} A formatted prompt string for AI outline generation
   * 
   * @description
   * The function constructs a multi-section prompt containing:
   * 
   * **Input Dependencies:**
   * - Requires `topicData` from the previous workflow step (TopicExplorationStep)
   * - Falls back to generic prompt if topicData is unavailable
   * 
   * **Prompt Structure:**
   * 1. **Context Section**: Provides topic, audience, tone, and key points from exploration
   * 2. **Conversation History**: Includes recent discussion context (last 4 messages) if available
   * 3. **Generation Instructions**: 5-point checklist for outline quality requirements
   * 4. **Output Format**: Strict formatting directives for parseable results
   * 
   * **Output Format Requirements:**
   * - `OUTLINE:` section with hierarchical bullet points and headers
   * - `SECTIONS:` section with numbered list of "Title | Description" pairs
   * - `ESTIMATED_WORD_COUNT:` section with numeric estimate
   * 
   * **Key Construction Details:**
   * - Joins key points array with comma separation for readability
   * - Conditionally includes conversation history only if present
   * - Limits conversation history to last 4 messages to prevent prompt bloat
   * - Uses template literals for clean string interpolation
   * - Maintains consistent formatting for reliable AI parsing
   * 
   * @example
   * ```typescript
   * // With complete topic data
   * const prompt = buildOutlinePrompt()
   * // Returns: "Create a comprehensive blog post outline based on the following topic exploration:
   * //           Topic: How to Build Better AI Products
   * //           Target Audience: Product Managers
   * //           ..."
   * 
   * // Without topic data
   * const prompt = buildOutlinePrompt() 
   * // Returns: "Please create a detailed blog post outline."
   * ```
   */
  const buildOutlinePrompt = () => {
    if (!topicData) {
      return 'Please create a detailed blog post outline.'
    }

    return `Create a comprehensive blog post outline based on the following topic exploration:

Topic: ${topicData.topic}
Target Audience: ${topicData.audience}
Tone: ${topicData.tone}
Key Points to Cover: ${topicData.keyPoints.join(', ')}

${topicData.conversationHistory ? `
Previous Topic Discussion:
${topicData.conversationHistory.slice(-4).map(msg => `${msg.role}: ${msg.content}`).join('\n\n')}
` : ''}

Please create a detailed outline that:
1. Has a compelling introduction that hooks the reader
2. Logically organizes the key points into 3-5 main sections
3. Includes practical examples and actionable insights
4. Has a strong conclusion with key takeaways
5. Is appropriate for the target audience and tone

Format your response as:

OUTLINE:
[Detailed outline with main points and subpoints]

SECTIONS:
1. Section Title | Brief description of what this section covers
2. Section Title | Brief description of what this section covers
[Continue for each section...]

ESTIMATED_WORD_COUNT: [Provide an estimate for the full blog post]`
  }

  /**
   * Generates a structured blog post outline using AI based on topic exploration data
   * 
   * This async function orchestrates the complete outline generation process, including
   * AI interaction tracking with Bilan SDK, response parsing, fallback handling, and
   * state management. It constructs prompts using topic data, calls the AI service,
   * parses the structured response, and updates the component state with the results.
   * 
   * @async
   * @function handleGenerateOutline
   * @returns {Promise<void>} Promise that resolves when outline generation is complete
   * 
   * @description
   * **Process Flow:**
   * 1. **Preparation**: Sets loading state and builds AI prompt using buildOutlinePrompt()
   * 2. **AI Generation**: Calls generateContentForType() via trackTurn() for Bilan analytics
   * 3. **Response Parsing**: Extracts outline, sections, and word count from AI response
   * 4. **State Updates**: Updates component state with parsed results
   * 5. **Error Handling**: Provides fallback outline if AI generation fails
   * 
   * **Bilan Integration:**
   * - Tracks turn with metadata: contentType, journeyId, step, userIntent
   * - Includes topicData context for analytics correlation
   * - Stores turnId for potential user voting/feedback
   * 
   * **Response Parsing Logic:**
   * - Looks for "OUTLINE:", "SECTIONS:", and "ESTIMATED_WORD_COUNT:" markers
   * - Parses sections using "Title | Description" format
   * - Falls back to extracting numbered/lettered items if parsing fails
   * - Provides sensible defaults for missing data
   * 
   * **Error Recovery:**
   * - Logs errors securely (message only, not full error object)
   * - Generates fallback outline using available topic data
   * - Creates default sections (Introduction, Main Content, Conclusion)
   * - Ensures UI remains functional even if AI service fails
   * 
   * **State Side Effects:**
   * - Updates `outline` with generated or fallback text
   * - Updates `sections` array with parsed section data
   * - Sets `estimatedWordCount` from AI or default value
   * - Manages `isGenerating`, `hasGenerated` loading states
   * - Stores `turnId` for voting functionality
   */
  const handleGenerateOutline = async () => {
    setIsGenerating(true)
    
    try {
      const prompt = buildOutlinePrompt()
      
      // Track the outline generation turn
      const { result, turnId: generatedTurnId } = await trackTurn(
        topicData ? `Generate outline for: ${topicData.topic}` : 'Generate blog outline',
        () => generateContentForType('blog', prompt),
        {
          contentType: 'blog',
          iterationNumber: 1,
          journey_id: journeyId,
          journey_step: 'outline-generation',
          userIntent: 'outline-generation',
          topicData: topicData ? {
            topic: topicData.topic,
            audience: topicData.audience,
            keyPoints: topicData.keyPoints
          } : undefined
        }
      )

      setTurnId(generatedTurnId)
      
      // Parse the AI response
      const responseText = result.text
      const lines = responseText.split('\n')
      
      let outlineText = ''
      let sectionsData: OutlineSection[] = []
      let wordCount = 800 // Default estimate
      
      let currentSection = ''
      
      for (const line of lines) {
        const trimmedLine = line.trim()
        
        if (trimmedLine.startsWith('OUTLINE:')) {
          currentSection = 'outline'
          continue
        } else if (trimmedLine.startsWith('SECTIONS:')) {
          currentSection = 'sections'
          continue
        } else if (trimmedLine.startsWith('ESTIMATED_WORD_COUNT:')) {
          const countMatch = trimmedLine.match(/(\d+)/)
          if (countMatch) {
            wordCount = parseInt(countMatch[1])
          }
          continue
        }
        
        if (currentSection === 'outline' && trimmedLine) {
          outlineText += line + '\n'
        } else if (currentSection === 'sections' && trimmedLine) {
          // Parse section format: "Number. Title | Description"
          const sectionMatch = trimmedLine.match(/^\d+\.\s*(.+?)\s*\|\s*(.+)$/)
          if (sectionMatch) {
            sectionsData.push({
              title: sectionMatch[1].trim(),
              description: sectionMatch[2].trim()
            })
          }
        }
      }
      
      // If parsing failed, extract sections from outline text
      if (sectionsData.length === 0 && outlineText) {
        const outlineLines = outlineText.split('\n').filter(line => line.trim())
        const sectionLines = outlineLines.filter(line => 
          line.match(/^\d+\./) || line.match(/^[A-Z]\./) || line.match(/^[IVX]+\./)
        )
        
        sectionsData = sectionLines.slice(0, 6).map((line, index) => ({
          title: line.replace(/^\d+\.\s*|^[A-Z]\.\s*|^[IVX]+\.\s*/, '').trim(),
          description: `Section ${index + 1} content`
        }))
      }
      
      setOutline(outlineText.trim())
      setSections(sectionsData)
      setEstimatedWordCount(wordCount)
      setHasGenerated(true)
      
    } catch (error) {
      console.error('Failed to generate outline:', error instanceof Error ? error.message : 'Unknown error')
      
      // Provide fallback outline
      const fallbackOutline = `Blog Post Outline for: ${topicData?.topic || 'Your Topic'}

1. Introduction
   - Hook to capture reader attention
   - Brief overview of the topic
   - Preview of key points

2. Main Content Sections
   ${topicData?.keyPoints.map((point, i) => `- ${point}`).join('\n   ') || '- Key point 1\n   - Key point 2\n   - Key point 3'}

3. Conclusion
   - Summary of main points
   - Call to action or next steps
   - Final thoughts`
      
      setOutline(fallbackOutline)
      setSections([
        { title: 'Introduction', description: 'Hook and overview of the topic' },
        { title: 'Main Content', description: 'Core points and detailed discussion' },
        { title: 'Conclusion', description: 'Summary and call to action' }
      ])
      setEstimatedWordCount(800)
      setHasGenerated(true)
    } finally {
      setIsGenerating(false)
      setIsAutoGenerating(false)
    }
  }

  /**
   * Records user satisfaction vote for the AI-generated blog outline
   * 
   * This asynchronous function handles user feedback voting on the quality and usefulness
   * of the AI-generated outline content. It integrates with Bilan analytics to capture
   * user satisfaction data and updates the local component state to reflect the user's
   * rating for immediate UI feedback and vote persistence.
   * 
   * **Core Functionality:**
   * - Validates turnId availability from outline generation before processing vote
   * - Submits user rating to Bilan analytics with contextual feedback message
   * - Updates local userVote state for UI display and interaction tracking
   * - Provides standardized feedback messages based on positive/negative ratings
   * - Handles voting errors gracefully without disrupting the outline workflow
   * 
   * **Voting Process:**
   * 1. **Turn Validation**: Verify valid turnId exists from previous outline generation
   * 2. **Bilan Integration**: Submit vote with rating and descriptive feedback message
   * 3. **State Update**: Update userVote state for immediate UI feedback display
   * 4. **Error Handling**: Log failures securely while maintaining workflow continuity
   * 
   * **Feedback Messages:**
   * The function provides contextual feedback to give meaning to the numeric rating:
   * - **Positive rating (1)**: "Helpful outline" - indicates outline met user expectations
   * - **Negative rating (-1)**: "Could be better" - indicates outline needs improvement
   * 
   * **State Management:**
   * Updates the userVote state to reflect the user's satisfaction rating, enabling:
   * - Visual indication of voting status in the UI (thumbs up/down highlighting)
   * - Prevention of duplicate voting through UI state management
   * - Persistence of user feedback throughout the outline generation session
   * 
   * **Analytics Integration:**
   * The vote is correlated with the original outline generation turnId from Bilan,
   * enabling comprehensive analysis of:
   * - User satisfaction patterns for outline quality assessment
   * - Content effectiveness metrics for AI model improvement
   * - User engagement levels and feedback frequency
   * - Outline generation performance and user experience insights
   * 
   * @async
   * @function handleVote
   * @param {1 | -1} rating - User satisfaction rating (1 for positive/helpful, -1 for negative/needs improvement)
   * @returns {Promise<void>} Promise that resolves when vote is recorded and state is updated
   * 
   * @throws {Error} Vote submission failures or state update errors are caught and logged securely
   * 
   * @description
   * **Security Considerations:**
   * Error logging uses sanitized approach to prevent exposure of sensitive information
   * including API credentials, user data, or internal system details while maintaining
   * debugging capability for development and troubleshooting purposes.
   * 
   * **Early Return Behavior:**
   * The function returns early without processing if no turnId is available,
   * which occurs when:
   * - No outline has been generated yet
   * - Outline generation failed without creating a turn
   * - Component state was reset or corrupted
   * 
   * **UI Integration:**
   * The userVote state update enables:
   * - Immediate visual feedback showing which rating was selected
   * - Disabled state for vote buttons after voting to prevent duplicates
   * - Persistent indication of user satisfaction throughout the session
   * 
   * @example
   * ```typescript
   * // User clicks thumbs up button on generated outline
   * await handleVote(1)
   * // Results in:
   * // - Bilan vote recorded with "Helpful outline" message
   * // - userVote state set to 1
   * // - UI shows positive feedback indication
   * 
   * // User clicks thumbs down button on generated outline
   * await handleVote(-1)
   * // Results in:
   * // - Bilan vote recorded with "Could be better" message
   * // - userVote state set to -1
   * // - UI shows negative feedback indication
   * ```
   */
  const handleVote = async (rating: 1 | -1) => {
    if (!turnId) return
    
    try {
      await vote(turnId, rating, rating === 1 ? 'Helpful outline' : 'Could be better')
      setUserVote(rating)
    } catch (error) {
      // Sanitize error logging to prevent exposure of sensitive information
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred'
      console.error('Failed to record vote:', errorMessage)
    }
  }

  /**
   * Resets outline-related state and triggers fresh AI-powered outline regeneration
   * 
   * This function provides users with the ability to discard the current outline and
   * generate a completely new version using the same topic data. It performs comprehensive
   * state cleanup to ensure a fresh start, then automatically initiates new outline
   * generation to maintain smooth user workflow continuity.
   * 
   * **Core Functionality:**
   * - Resets generation status flags to allow new outline creation
   * - Clears existing outline content and extracted sections data
   * - Removes previous Bilan analytics tracking identifiers
   * - Resets user feedback state to neutral for new evaluation
   * - Automatically triggers fresh outline generation process
   * 
   * **State Reset Process:**
   * 1. **Generation Flag**: Sets `hasGenerated` to false, enabling new generation UI
   * 2. **Content Cleanup**: Clears `outline` string, removing previous AI-generated content
   * 3. **Section Reset**: Empties `sections` array, clearing extracted section data
   * 4. **Analytics Reset**: Clears `turnId`, disconnecting from previous Bilan tracking
   * 5. **Feedback Reset**: Sets `userVote` to null, removing previous satisfaction rating
   * 6. **Auto-Regeneration**: Calls `handleGenerateOutline()` to start fresh generation
   * 
   * **User Experience Benefits:**
   * - **Fresh Start**: Complete state reset ensures no residual data affects new generation
   * - **Seamless Workflow**: Automatic regeneration maintains user momentum
   * - **Clean Analytics**: Each regeneration gets independent Bilan tracking
   * - **Unbiased Feedback**: Reset vote state allows fresh user evaluation
   * - **Consistent UI**: Generation flags ensure proper loading states and button visibility
   * 
   * **Business Logic Context:**
   * This function serves as a critical workflow recovery mechanism when users are
   * unsatisfied with generated outline quality. It enables iterative content creation
   * by allowing multiple generation attempts while maintaining clean state separation
   * between each attempt for accurate analytics and user experience.
   * 
   * **Analytics Implications:**
   * By clearing the turnId and userVote state, each regeneration creates independent
   * Bilan tracking events, enabling analysis of:
   * - Regeneration frequency and user satisfaction patterns
   * - Quality improvement across multiple generation attempts
   * - User engagement with iterative content creation workflow
   * - Outline generation success rates and abandonment points
   * 
   * @function handleRegenerateOutline
   * @returns {void} No return value - function performs state updates and triggers generation
   * 
   * @description
   * **State Management:**
   * All state updates are synchronous using React's setState functions, ensuring
   * immediate UI updates and proper component re-rendering before triggering the
   * asynchronous outline generation process.
   * 
   * **Workflow Integration:**
   * This function integrates seamlessly with the outline generation workflow by:
   * - Preserving original topic data from previous steps
   * - Maintaining user context (audience, tone, key points)
   * - Ensuring fresh Bilan analytics tracking for each attempt
   * - Providing consistent user experience across multiple generations
   * 
   * **UI State Transitions:**
   * The function triggers several UI state changes:
   * - Shows generation loading state via `hasGenerated: false`
   * - Hides previous outline content and feedback buttons
   * - Displays fresh generation progress indicators
   * - Resets vote button states to neutral appearance
   * 
   * @example
   * ```typescript
   * // User clicks "Regenerate Outline" button after reviewing unsatisfactory outline
   * handleRegenerateOutline()
   * 
   * // Results in immediate state changes:
   * // - hasGenerated: false (shows loading state)
   * // - outline: '' (clears previous content)  
   * // - sections: [] (removes extracted sections)
   * // - turnId: '' (resets analytics tracking)
   * // - userVote: null (clears previous feedback)
   * // - Automatic call to handleGenerateOutline() for fresh generation
   * ```
   */
  const handleRegenerateOutline = () => {
    setHasGenerated(false)
    setOutline('')
    setSections([])
    setTurnId('')
    setUserVote(null)
    handleGenerateOutline()
  }

  const handleEditOutline = (newOutline: string) => {
    setOutline(newOutline)
    
    // Try to extract sections from edited outline
    const lines = newOutline.split('\n').filter(line => line.trim())
    const sectionLines = lines.filter(line => 
      line.match(/^\d+\./) || line.match(/^[A-Z]\./) || line.match(/^[IVX]+\./)
    )
    
    if (sectionLines.length > 0) {
      const updatedSections = sectionLines.slice(0, 6).map((line, index) => ({
        title: line.replace(/^\d+\.\s*|^[A-Z]\.\s*|^[IVX]+\.\s*/, '').trim(),
        description: sections[index]?.description || `Section ${index + 1} content`
      }))
      setSections(updatedSections)
    }
  }

  /**
   * Completes the outline generation step by aggregating data and triggering workflow progression
   * 
   * This function serves as the primary completion handler for the outline generation workflow step,
   * responsible for collecting all outline-related data, validating completion readiness, and
   * passing the aggregated information to the parent workflow component for progression to the
   * next step in the blog creation process.
   * 
   * **Core Functionality:**
   * - Validates outline content exists before proceeding with completion
   * - Aggregates outline data into structured OutlineGenerationData format
   * - Includes generated content, extracted sections, and workflow metadata
   * - Triggers parent workflow progression via onComplete callback
   * - Maintains data integrity and completeness for subsequent workflow steps
   * 
   * **Data Aggregation Process:**
   * 1. **Content Validation**: Verify outline exists and contains meaningful content
   * 2. **Data Collection**: Gather outline text, sections array, word count estimate
   * 3. **Metadata Addition**: Add timestamp marking completion moment
   * 4. **Structure Creation**: Build typed OutlineGenerationData object
   * 5. **Workflow Progression**: Call onComplete to advance to section writing step
   * 
   * **Aggregated Data Structure:**
   * The function creates an OutlineGenerationData object containing:
   * - **outline**: Trimmed outline text content generated by AI or edited by user
   * - **sections**: Array of extracted section objects with titles and descriptions
   * - **estimatedWordCount**: Calculated word count estimate for the complete blog post
   * - **generatedAt**: Timestamp marking when outline generation was completed
   * 
   * **Workflow Integration:**
   * This completion handler integrates with the broader blog workflow by:
   * - Preserving all outline data for use in subsequent section writing step
   * - Enabling section-by-section content creation based on outline structure
   * - Providing word count estimates for user planning and content scope understanding
   * - Maintaining completion timestamps for analytics and user journey tracking
   * 
   * **Business Logic Context:**
   * The function represents a critical workflow checkpoint, ensuring users cannot
   * proceed to section writing without a valid outline foundation. This prevents
   * downstream errors and ensures a structured approach to blog content creation
   * that aligns with professional content development best practices.
   * 
   * **Early Return Behavior:**
   * The function implements validation by returning early if no outline content
   * exists, preventing workflow progression with incomplete data and maintaining
   * user experience consistency by requiring meaningful outline content before
   * allowing step completion.
   * 
   * @function handleComplete
   * @returns {void} No return value - function triggers workflow progression via callback
   * 
   * @description
   * **Parent Component Integration:**
   * The function communicates with the parent BlogWorkflow component through the
   * onComplete callback prop, which handles:
   * - Updating overall workflow state with outline data
   * - Progressing to the next workflow step (section writing)
   * - Tracking step completion with Bilan analytics
   * - Managing UI state transitions and step indicators
   * 
   * **Data Persistence:**
   * The aggregated OutlineGenerationData is preserved in the parent workflow state,
   * ensuring outline information remains available throughout the remaining workflow
   * steps for reference, section creation, and final blog assembly.
   * 
   * **Quality Assurance:**
   * By requiring trimmed outline content and validating existence, the function
   * ensures data quality and prevents empty or whitespace-only outlines from
   * progressing through the workflow, maintaining content creation standards.
   * 
   * **Analytics Integration:**
   * The generatedAt timestamp enables analytics tracking of:
   * - Time spent in outline generation step
   * - Completion rates and workflow progression patterns
   * - User engagement duration and step-specific performance metrics
   * - Overall blog creation journey timing and efficiency
   * 
   * @example
   * ```typescript
   * // User clicks "Continue to Section Writing" button after reviewing outline
   * handleComplete()
   * 
   * // Function performs validation and data aggregation:
   * // 1. Checks outline.trim() exists
   * // 2. Creates OutlineGenerationData object:
   * //    - outline: "1. Introduction\n2. Main Content\n3. Conclusion"
   * //    - sections: [{title: "Introduction", description: "..."}, ...]
   * //    - estimatedWordCount: 1200
   * //    - generatedAt: 1701234567890
   * // 3. Calls onComplete(outlineData) to progress workflow
   * // 4. Parent component advances to section writing step
   * ```
   */
  const handleComplete = () => {
    if (!outline.trim()) return

    const outlineData: OutlineGenerationData = {
      outline: outline.trim(),
      sections,
      estimatedWordCount,
      generatedAt: Date.now()
    }

    onComplete(outlineData)
  }

  return (
    <Stack gap="lg">
      <div>
        <Title order={3} mb="xs">Outline Generation</Title>
        <Text c="dimmed" size="sm">
          Create a structured outline for your blog post. This will serve as the blueprint for your content.
        </Text>
      </div>

      {/* Topic Summary */}
      {topicData && (
        <Card withBorder p="md" bg="blue.0">
          <Text fw={500} mb="sm">Topic Summary</Text>
          <Group gap="xs" mb="sm">
            <Badge variant="light" color="blue">Topic</Badge>
            <Text size="sm">{topicData.topic}</Text>
          </Group>
          <Group gap="xs" mb="sm">
            <Badge variant="light" color="green">Audience</Badge>
            <Text size="sm">{topicData.audience}</Text>
          </Group>
          <Group gap="xs" mb="sm">
            <Badge variant="light" color="orange">Tone</Badge>
            <Text size="sm" tt="capitalize">{topicData.tone}</Text>
          </Group>
          <Group gap="xs">
            <Badge variant="light" color="purple">Key Points</Badge>
            <Text size="sm">{topicData.keyPoints.join(', ')}</Text>
          </Group>
        </Card>
      )}

      {/* Auto-generation indicator */}
      {isAutoGenerating && (
        <Alert color="blue" title="Generating Outline">
          <Group gap="sm">
            <Loader size="sm" />
            <Text size="sm">Creating your blog outline based on the topic exploration...</Text>
          </Group>
        </Alert>
      )}

      {/* Generated Outline */}
      {hasGenerated && (
        <>
          <Card withBorder p="md">
            <Group justify="space-between" mb="md">
              <Text fw={500}>Generated Outline</Text>
              <Group gap="sm">
                <Text size="xs" c="dimmed">~{estimatedWordCount} words</Text>
                {/* Vote buttons */}
                {turnId && (
                  <Group gap="xs">
                    <Button
                      size="xs"
                      variant={userVote === 1 ? 'filled' : 'light'}
                      color="green"
                      onClick={() => handleVote(1)}
                    >
                      👍 Good
                    </Button>
                    <Button
                      size="xs"
                      variant={userVote === -1 ? 'filled' : 'light'}
                      color="red"
                      onClick={() => handleVote(-1)}
                    >
                      👎 Not helpful
                    </Button>
                  </Group>
                )}
                <Button
                  size="xs"
                  variant="light"
                  onClick={handleRegenerateOutline}
                  loading={isGenerating}
                >
                  Regenerate
                </Button>
              </Group>
            </Group>

            <Textarea
              value={outline}
              onChange={(e) => handleEditOutline(e.target.value)}
              minRows={12}
              maxRows={20}
              placeholder="Your blog outline will appear here..."
              styles={{
                input: {
                  fontFamily: 'monospace',
                  fontSize: '14px',
                  lineHeight: 1.5
                }
              }}
            />
          </Card>

          {/* Section Breakdown */}
          {sections.length > 0 && (
            <Card withBorder p="md">
              <Text fw={500} mb="md">Section Breakdown</Text>
              <Stack gap="sm">
                {sections.map((section, index) => (
                  <Paper key={index} p="sm" withBorder bg="gray.0">
                    <Group justify="space-between" align="flex-start">
                      <div style={{ flex: 1 }}>
                        <Text fw={500} size="sm" mb="xs">
                          {index + 1}. {section.title}
                        </Text>
                        <Text size="xs" c="dimmed">
                          {section.description}
                        </Text>
                      </div>
                      <Badge size="xs" color="gray">
                        Section {index + 1}
                      </Badge>
                    </Group>
                  </Paper>
                ))}
              </Stack>
            </Card>
          )}
        </>
      )}

      {/* Generate Button (if not auto-generated) */}
      {!hasGenerated && !isAutoGenerating && (
        <Card withBorder p="md" ta="center">
          <Text c="dimmed" mb="md">
            {topicData 
              ? "Click below to generate your blog outline based on your topic exploration."
              : "Click below to generate a blog outline. (For best results, complete topic exploration first.)"
            }
          </Text>
          <Button
            onClick={handleGenerateOutline}
            loading={isGenerating}
            size="md"
          >
            Generate Outline
          </Button>
        </Card>
      )}

      {/* Action Buttons */}
      <Group justify="space-between">
        <div>
          {/* Could add outline template options here */}
        </div>
        
        <Button 
          onClick={handleComplete}
          disabled={!outline.trim()}
          size="md"
        >
          Complete Outline Generation
        </Button>
      </Group>

      {!outline.trim() && hasGenerated && (
        <Alert color="yellow" title="Outline Required">
          Please generate or enter a blog outline to continue to the next step.
        </Alert>
      )}
    </Stack>
  )
} 